"use client";

import { useMemo, useState } from "react";
import { PromptConfigurator, RESOLUTION_OPTIONS } from "@/components/prompt-configurator";
import { RenderViewport } from "@/components/render-viewport";
import { SceneInspector } from "@/components/scene-inspector";
import { HistoryPanel } from "@/components/history-panel";
import { useVideoGenerator } from "@/hooks/use-video-generator";
import { analyzePrompt, buildSceneShots } from "@/lib/prompt";
import { hashStringToSeed } from "@/lib/random";
import type {
  GenerationHistoryItem,
  GenerationSettings,
  VideoStyle,
} from "@/lib/types";

const DEFAULT_PROMPT =
  "A sweeping aerial shot over a neon-drenched megacity during a torrential downpour, volumetric rain streaking past the lens, holographic whales drifting between skyscrapers.";
const DEFAULT_STYLE: VideoStyle = "cinematic";
const DEFAULT_RESOLUTION = RESOLUTION_OPTIONS[1];
const FPS = 30;

const FEATURE_GRID = [
  {
    title: "Procedural Motion Field",
    description:
      "Dynamic particle orchestration that adapts to the mood and speed of your prompt with seeded reproducibility.",
  },
  {
    title: "Temporal Shot Planner",
    description:
      "Autogenerated storyboard beats with cinematic timing tuned to your narrative intent.",
  },
  {
    title: "Real-Time Web Encoding",
    description:
      "Browser-native pipeline using MediaRecorder streams for instant playable WebM sequences.",
  },
];

type ResolutionOption = (typeof RESOLUTION_OPTIONS)[number];

export default function Home() {
  const [prompt, setPrompt] = useState(DEFAULT_PROMPT);
  const [duration, setDuration] = useState(6);
  const [style, setStyle] = useState<VideoStyle>(DEFAULT_STYLE);
  const [resolution, setResolution] = useState<ResolutionOption>(DEFAULT_RESOLUTION);
  const [history, setHistory] = useState<GenerationHistoryItem[]>([]);

  const {
    canvasRef,
    generate,
    status,
    progress,
    videoUrl,
    error,
    reset,
    loadFromHistory,
  } = useVideoGenerator();

  const sceneProfile = useMemo(() => analyzePrompt(prompt, style), [prompt, style]);
  const sceneShots = useMemo(
    () => buildSceneShots(prompt, duration, sceneProfile),
    [prompt, duration, sceneProfile],
  );

  const generating = status === "rendering" || status === "encoding";

  const handleGenerate = async () => {
    const seed = hashStringToSeed(`${prompt}-${style}-${duration}-${resolution.label}`);
    const settings: GenerationSettings = {
      prompt,
      duration,
      fps: FPS,
      width: resolution.width,
      height: resolution.height,
      style,
      seed,
    };

    try {
      const result = await generate(settings, sceneProfile);
      const historyUrl = URL.createObjectURL(result.blob);
      const profileSnapshot = {
        ...sceneProfile,
        palette: {
          background: [...sceneProfile.palette.background],
          accents: [...sceneProfile.palette.accents],
        },
        motion: { ...sceneProfile.motion },
        narrativeBeats: [...sceneProfile.narrativeBeats],
      };
      const record: GenerationHistoryItem = {
        id: `${Date.now()}`,
        prompt,
        createdAt: Date.now(),
        settings: { ...settings },
        videoUrl: historyUrl,
        sceneProfile: profileSnapshot,
        shots: sceneShots.map((shot) => ({ ...shot })),
      };
      setHistory((prev) => [record, ...prev].slice(0, 6));
    } catch (generationError) {
      console.error("Generation error", generationError);
    }
  };

  const handleLoadHistory = (item: GenerationHistoryItem) => {
    setPrompt(item.prompt);
    setDuration(item.settings.duration);
    setStyle(item.settings.style);

    const match =
      RESOLUTION_OPTIONS.find(
        (option) =>
          option.width === item.settings.width && option.height === item.settings.height,
      ) ?? RESOLUTION_OPTIONS[0];

    setResolution(match);
    reset();
    loadFromHistory(item.videoUrl);
  };

  return (
    <main className="relative min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 text-slate-100">
      <div className="absolute inset-x-0 top-0 z-0 h-[500px] bg-gradient-to-b from-fuchsia-500/20 via-transparent to-transparent blur-3xl" />
      <div className="relative z-10 mx-auto flex max-w-7xl flex-col gap-12 px-4 pb-24 pt-16 sm:px-8 lg:px-12">
        <header className="flex flex-col gap-6">
          <span className="text-xs font-semibold uppercase tracking-[0.4em] text-fuchsia-200">
            Sora-2 Inspired Pipeline
          </span>
          <h1 className="text-4xl font-semibold leading-tight text-white md:text-5xl">
            Generate cinematic video sequences from pure imagination.
          </h1>
          <p className="max-w-3xl text-lg text-slate-300">
            The Sora-2 Studio orchestrates scene understanding, motion synthesis, and temporal
            encoding to prototype AI videos directly in your browser. Describe your world and watch
            it animate in real time.
          </p>
          <div className="grid gap-4 md:grid-cols-3">
            {FEATURE_GRID.map((feature) => (
              <div
                key={feature.title}
                className="rounded-2xl border border-white/10 bg-white/[0.04] p-4 shadow-sm"
              >
                <h3 className="text-sm font-semibold text-white">{feature.title}</h3>
                <p className="mt-2 text-sm text-slate-300">{feature.description}</p>
              </div>
            ))}
          </div>
        </header>

        <RenderViewport
          canvasRef={canvasRef}
          videoUrl={videoUrl}
          status={status}
          progress={progress}
          error={error}
        />

        <PromptConfigurator
          prompt={prompt}
          duration={duration}
          style={style}
          resolution={resolution}
          onPromptChange={setPrompt}
          onDurationChange={setDuration}
          onStyleChange={setStyle}
          onResolutionChange={setResolution}
          onGenerate={handleGenerate}
          generating={generating}
          progress={progress}
        />

        <SceneInspector profile={sceneProfile} shots={sceneShots} />

        <HistoryPanel items={history} onLoad={handleLoadHistory} />
      </div>
    </main>
  );
}
